#################### For lidar - get index of actual ground coverage #####################
# For lidar data or image data, it is easy to create an index using the min and max xy, but often,
# images are at an angle and surrounded with NA values to produce a rectangular image. This function
# should be run on a polygon file of the ACTUAL ground coverage, excluding NAs. If it doesn't already 
# exist, this polygon can be generated by first  running the imageCoverage function on the DTMs or DSMs
# or some other image dataset based on the lidar data (or on any image dataset for which you wish to have 
# an index. Images with higher resolution will produce a more accurate and precise index.
#
# This script will intersect the two input polygon files and assign the file path of each tile to 
# its associated ground coverage polygon. This process is important for ensuring proper (i.e., complete)
# plot extraction.
#
# Inputs: actual ground coverage polygon, an index of lidar (or image) tiles (polygon), the name of the field
# that contains the output index name.
# The coarse index must have a field that contains the file path of the tile.
# 
# Requires rgdal and raster

# TRY DIFFERENT TEST SHAPEFILES
# # grndCoveragePoly <- "/mnt/a/tcormier/testing/junk_cutzamala_grnd_with-shapely.shp"
# # grndCoveragePoly <- readOGR(dirname(grndCoveragePoly), unlist(strsplit(basename(grndCoveragePoly), "\\."))[1])
# # grndCoveragePoly <- readOGR("/mnt/a/tcormier/testing/", "junk", stringsAsFactors = F)
# grndCoveragePoly <- readOGR(dirname(outpoly), unlist(strsplit(basename(outpoly), "\\."))[1])
# # grndCoveragePoly <- readOGR("/mnt/a/tcormier/testing/", "Cartodata_coverage_all_itrf93_UTM15N", stringsAsFactors = F)
# # coarseIndexPoly <- readOGR("/mnt/a/tcormier/Mexico_CMS/lidar/index/","Oaxaca3_index", stringsAsFactors=F)
# # # library(maptools)
# # grndCoveragePoly <- readShapePoly(outpoly)
# # # coarseIndexPoly <- readShapePoly("/mnt/a/tcormier/Mexico_CMS/lidar/index/Oaxaca3_index.shp")
# coarseIndexPoly <- readOGR(dirname("/mnt/a/tcormier/Mexico_CMS/lidar/index/Cutzamala_index_with-shapely.shp"), unlist(strsplit(basename("/mnt/a/tcormier/Mexico_CMS/lidar/index/Cutzamala_index.shp"), "\\."))[1])
# # coarseIndexPoly <- "/mnt/r/Mex_Lidar/Cartodata/Cutzamala/Tiling_scheme/EdoMex_TilingScheme.shp"
# # coarseIndexPoly <- readOGR(dirname(coarseIndexPoly), unlist(strsplit(basename(coarseIndexPoly), "\\."))[1])
# outIndex <- "/mnt/a/tcormier/testing/test_cutzamala_groundIndex.shp"

# From mac
coarseIndexPoly <- readOGR(dirname("/Users/tcormier/Documents/test/Cutzamala_index.shp"), unlist(strsplit(basename("/Users/tcormier/Documents/test/Cutzamala_index.shp"), "\\."))[1])
grndCoveragePoly <- readOGR(dirname("/Users/tcormier/Documents/test/junk_cutzamala_grnd.shp"), unlist(strsplit(basename("/Users/tcormier/Documents/test/junk_cutzamala_grnd.shp"), "\\."))[1])
outIndex <- "/Users/tcormier/Documents/test/test_cutzamala_groundIndex.shp"

groundIndex <- function(grndCoveragePoly, coarseIndexPoly, outIndex) {
  library(rgdal)
  library(raster)
  library(rgeos)
  library(sp)
  # library(RPostgreSQL)
  library(RQGIS)
  rasterOptions(tmpdir="/home/tcormier/RasTmpDir/")
  
  # Using raster::intersect would be idea, but it doesn't return all of the tiles for 
  # some reason, leaving holes in the index. 
  # index.union <- raster::union(grndCoveragePoly, coarseIndexPoly)
  #   writeOGR(grndCoveragePoly, "PG:dbname='tcormier' host='fusion' port='5433' ", layer_options = "geometry_name=geom", 
  #            "grndCoveragePoly", "PostgreSQL")
  #   writeOGR(coarseIndexPoly, "PG:dbname='tcormier' host='fusion' port='5433' ", layer_options = "geometry_name=geom", 
  #            "coarseIndexPoly", "PostgreSQL")
  
  
  # Read it back in to see if it's fixed
  # dsn <- "PG:dbname='tcormier' host='fusion' port='5433' "
  # ogrListLayers(dsn)
  # grndCoveragePoly = readOGR(dsn="PG:host='fusion' port='5433' dbname='tcormier' user='tcormier' password='6yhn6yhn'","junk_cutzamala_grnd")
  # 
  # index.self <- raster::intersect(coarseIndexPoly, coarseIndexPoly)
  
  # Try RQGIS package
  # set the environment, i.e. specify all the paths necessary to run QGIS from 
  # within R
  my_env <- set_env(root="/Applications/QGIS_214.app")
  find_algorithms(search_term = "intersection", 
                  qgis_env = my_env)
  get_usage(alg = "qgis:intersection",
            qgis_env = my_env,
            intern = TRUE)
  params <- get_args_man(alg = "qgis:intersection", 
                         qgis_env = my_env)
  
  params$INPUT <- coarseIndexPoly
  params$INPUT2 <- grndCoveragePoly
  params$OUTPUT <- outIndex
  
  out <- run_qgis(alg = "qgis:intersection",
                  params = params,
                  load_output = params$OUTPUT_LAYER,
                  qgis_env = my_env)
  
  
  
  ###################
  index.int <- raster::union(grndCoveragePoly, coarseIndexPoly)
  index.int2 <- raster::crop(index.int, grndCoveragePoly)
  index.cover <- raster::cover(grndCoveragePoly, coarseIndexPoly)
  # index.crop <- raster::crop(coarseIndexPoly, grndCoveragePoly)
  # index.gInt <- gIntersection(coarseIndexPoly, grndCoveragePoly, byid = T, drop_lower_td = T)
  # index.grnd <- index.union[!duplicated(index.union@data$location) & !is.na(index.union@data$location),]
  
  
  writeOGR(index.int, "/mnt/a/tcormier/testing/", "junk3", driver = "ESRI Shapefile", overwrite=T)
  
}